<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IR Controller - Arduino Nanos</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-900 text-white min-h-screen">
  <div class="container mx-auto p-4 lg:p-6 max-w-7xl space-y-4">
    <header class="flex justify-between items-center mb-4">
      <h1 class="text-3xl font-bold text-purple-400">ğŸ“¡ IR Controller</h1>
      <div class="flex items-center gap-4">
        <button onclick="window.close()" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg text-sm font-medium transition-colors">
          âœ• Fechar
        </button>
        <div class="text-sm text-slate-400">Arduino Nanos Interface</div>
      </div>
    </header>

    <!-- ConfiguraÃ§Ã£o das Portas IR -->
    <div class="bg-slate-800/50 p-4 rounded-lg border border-slate-700">
      <h2 class="text-lg font-semibold text-slate-300 border-b border-slate-600 pb-2 mb-4">ConfiguraÃ§Ã£o dos Arduino Nanos</h2>
      
      <!-- Nano 1 (Porta 3) -->
      <div class="flex flex-wrap items-center gap-4 mb-4">
        <label class="text-slate-400 font-medium">Arduino Nano 1:</label>
        
        <button id="connectPort3" onclick="connectPort3()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg font-medium transition-colors">
          ğŸ”Œ Conectar Nano 1
        </button>
        
        <button id="disconnectPort3" onclick="disconnectPort3()" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg font-medium transition-colors" style="display: none;">
          ğŸ”Œ Desconectar Nano 1
        </button>
        
        <span id="statusPort3" class="text-sm text-slate-500">Desconectado</span>
      </div>

      <!-- Nano 2 (Porta 4) -->
      <div class="flex flex-wrap items-center gap-4 mb-4">
        <label class="text-slate-400 font-medium">Arduino Nano 2:</label>
        
        <button id="connectPort4" onclick="connectPort4()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg font-medium transition-colors">
          ğŸ”Œ Conectar Nano 2
        </button>
        
        <button id="disconnectPort4" onclick="disconnectPort4()" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg font-medium transition-colors" style="display: none;">
          ğŸ”Œ Desconectar Nano 2
        </button>
        
        <span id="statusPort4" class="text-sm text-slate-500">Desconectado</span>
      </div>
    </div>

    <!-- Comandos IR -->
    <div class="bg-slate-800/50 p-4 rounded-lg border border-slate-700">
      <h3 class="text-lg font-semibold text-slate-300 border-b border-slate-600 pb-2 mb-4">Comandos IR</h3>
      
      <div class="flex flex-wrap gap-4 mb-4">
        <button onclick="sendGetCommand('port3')" class="px-6 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition-colors">
          ğŸ“¡ GET Nano 1
        </button>
        
        <button onclick="sendGetCommand('port4')" class="px-6 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition-colors">
          ğŸ“¡ GET Nano 2
        </button>
        
        <button onclick="testBothPorts()" class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-lg font-medium transition-colors">
          ğŸ”„ Testar Ambos
        </button>
      </div>

      <div class="flex flex-wrap gap-4">
        <button onclick="resetNano('port3')" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 rounded-lg text-sm transition-colors">
          ğŸ”„ Reset Nano 1
        </button>
        
        <button onclick="resetNano('port4')" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 rounded-lg text-sm transition-colors">
          ğŸ”„ Reset Nano 2
        </button>
        
        <button onclick="clearLogs()" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg text-sm transition-colors">
          ğŸ—‘ï¸ Limpar Logs
        </button>
      </div>
    </div>

    <!-- Logs -->
    <div class="bg-slate-800/50 p-4 rounded-lg border border-slate-700">
      <h3 class="text-lg font-semibold text-slate-300 border-b border-slate-600 pb-2 mb-4">Logs de ComunicaÃ§Ã£o</h3>
      
      <div class="flex gap-4 mb-4">
        <button onclick="clearLogs()" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg text-sm transition-colors">
          ğŸ—‘ï¸ Limpar Logs
        </button>
        <button onclick="toggleAutoSave()" id="autoSaveBtn" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm transition-colors">
          âœ… Auto-Save ON
        </button>
        <button onclick="saveGetNanoLogs()" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm transition-colors">
          ğŸ“¡ Salvar Manual
        </button>
      </div>
      
      <div id="logContainer" class="bg-slate-900/50 p-3 rounded-lg max-h-96 overflow-y-auto font-mono text-sm space-y-1">
        <div class="text-slate-400">ğŸ“¡ IR Controller iniciado - Pronto para conectar Arduino Nanos</div>
      </div>
    </div>
  </div>

  <script>
    // Estado global
    let serialPorts = new Map();
    let portConnections = new Map();
    let getNanoLogs = []; // Array especÃ­fico para logs GET Nano
    let autoSaveEnabled = true; // Salvamento automÃ¡tico ativado
    let pendingGetCommand = null; // Para rastrear comando GET pendente
    
    // WebSocket para comunicaÃ§Ã£o com API
    let apiWebSocket = null;
    let apiConnected = false;

    // Verificar suporte
    if (!('serial' in navigator)) {
      addLog('âŒ Web Serial API nÃ£o suportada neste browser', 'error');
    }

    // Conectar WebSocket com API
    function connectToAPI() {
      try {
        apiWebSocket = new WebSocket('ws://localhost:8081');
        
        apiWebSocket.onopen = () => {
          apiConnected = true;
          addLog('ğŸ”— Conectado com API via WebSocket');
          sendConnectionStatus();
        };
        
        apiWebSocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleAPIMessage(data);
          } catch (error) {
            addLog(`âŒ Erro ao processar mensagem da API: ${error.message}`, 'error');
          }
        };
        
        apiWebSocket.onclose = () => {
          apiConnected = false;
          addLog('ğŸ”— ConexÃ£o com API perdida', 'warn');
          // Tentar reconectar em 5 segundos
          setTimeout(connectToAPI, 5000);
        };
        
        apiWebSocket.onerror = (error) => {
          addLog('âŒ Erro na conexÃ£o WebSocket com API', 'error');
        };
        
      } catch (error) {
        addLog('âŒ Falha ao conectar WebSocket: ' + error.message, 'error');
      }
    }

    // Processar mensagens da API
    function handleAPIMessage(data) {
      addLog(`ğŸ“¨ API: ${data.type} para ${data.nano}`);
      
      if (data.type === 'execute_get') {
        // API solicitou execuÃ§Ã£o de GET
        const { nano, requestId, payload } = data;
        addLog(`ğŸ”„ Executando GET para ${nano} via API (ID: ${requestId})`);
        
        if (nano === 'nano1') {
          executeAPIGetCommand('port3', 'Nano 1', requestId);
        } else if (nano === 'nano2') {
          executeAPIGetCommand('port4', 'Nano 2', requestId);
        }
      }
    }

    // Executar comando GET solicitado pela API
    async function executeAPIGetCommand(portKey, portName, requestId) {
      const portData = serialPorts.get(portKey);
      
      if (!portData) {
        sendAPIResponse(portKey === 'port3' ? 'nano1' : 'nano2', null, requestId, 'Arduino nÃ£o conectado');
        return;
      }

      try {
        const command = 'GET\n';
        const encoder = new TextEncoder();
        await portData.writer.write(encoder.encode(command));
        
        addLog(`ğŸ“¡ â†’ ${portName}: GET (API Request)`, 'send');
        
        // Aguardar resposta e enviar para API
        setTimeout(() => {
          const recentLogs = getNanoLogs.filter(log => 
            log.message.includes(portName) && 
            log.type === 'receive' &&
            new Date(log.timestamp) > new Date(Date.now() - 3000)
          );
          
          const responseData = recentLogs.map(log => log.message.replace(`ğŸ“¡ â† ${portName}: `, '')).join('\n');
          sendAPIResponse(portKey === 'port3' ? 'nano1' : 'nano2', responseData, requestId);
          
        }, 2000);
        
      } catch (error) {
        addLog(`âŒ Erro ao enviar GET para ${portName} via API: ${error.message}`, 'error');
        sendAPIResponse(portKey === 'port3' ? 'nano1' : 'nano2', null, requestId, error.message);
      }
    }

    // Enviar resposta para API
    function sendAPIResponse(nano, response, requestId, error = null) {
      if (!apiConnected || !apiWebSocket) return;
      
      const message = {
        type: 'get_response',
        nano: nano,
        response: response,
        timestamp: new Date().toISOString(),
        requestId: requestId,
        error: error
      };
      
      apiWebSocket.send(JSON.stringify(message));
      
      if (error) {
        addLog(`ğŸ“¨ Erro enviado para API: ${error}`, 'error');
      } else {
        addLog(`ğŸ“¨ Resposta enviada para API: ${nano}`, 'info');
      }
    }

    // Enviar status de conexÃ£o para API
    function sendConnectionStatus() {
      if (!apiConnected || !apiWebSocket) return;
      
      const message = {
        type: 'connection_status',
        nano1Connected: serialPorts.has('port3'),
        nano2Connected: serialPorts.has('port4'),
        timestamp: new Date().toISOString()
      };
      
      apiWebSocket.send(JSON.stringify(message));
    }

    // Inicializar conexÃ£o WebSocket ao carregar a pÃ¡gina
    window.addEventListener('load', () => {
      setTimeout(connectToAPI, 1000);
    });

    // FunÃ§Ãµes de logging
    function addLog(message, type = 'info') {
      const container = document.getElementById('logContainer');
      const timestamp = new Date().toLocaleTimeString();
      const fullTimestamp = new Date().toISOString();
      
      // Se for comando GET enviado ou resposta recebida de GET, armazenar
      if ((type === 'send' && message.includes('GET')) || 
          (type === 'receive' && message.includes('â† Nano'))) {
        
        const getNanoEntry = {
          timestamp: fullTimestamp,
          displayTime: timestamp,
          message: message,
          type: type,
          isGetRelated: true
        };
        getNanoLogs.push(getNanoEntry);

        // Se for comando GET enviado, marcar como pendente
        if (type === 'send' && message.includes('GET')) {
          pendingGetCommand = {
            timestamp: fullTimestamp,
            nano: message.includes('Nano 1') ? 'Nano1' : 'Nano2'
          };
        }

        // Se for resposta recebida e hÃ¡ comando pendente, salvar automaticamente
        if (type === 'receive' && pendingGetCommand && autoSaveEnabled) {
          // Aguardar um pouco para capturar todas as linhas da resposta
          setTimeout(() => {
            autoSaveGetNanoLogs();
            pendingGetCommand = null;
          }, 1000);
        }
      }
      
      // Mostrar no UI
      const logDiv = document.createElement('div');
      logDiv.className = getLogClass(type);
      logDiv.textContent = `${timestamp} - ${message}`;
      
      container.appendChild(logDiv);
      container.scrollTop = container.scrollHeight;
      
      // Limitar logs na interface (manter Ãºltimos 200)
      if (container.children.length > 200) {
        container.removeChild(container.firstChild);
      }
    }

    function getLogClass(type) {
      switch(type) {
        case 'error': return 'text-red-400';
        case 'warn': return 'text-yellow-400';
        case 'send': return 'text-blue-400';
        case 'receive': return 'text-green-400';
        default: return 'text-slate-300';
      }
    }

    function clearLogs() {
      document.getElementById('logContainer').innerHTML = '<div class="text-slate-400">ğŸ“¡ Logs limpos</div>';
      getNanoLogs = [];
      pendingGetCommand = null;
      addLog('ğŸ“¡ Logs limpos - Array GET Nano resetado');
    }

    // FunÃ§Ã£o para alternar auto-save
    function toggleAutoSave() {
      autoSaveEnabled = !autoSaveEnabled;
      const btn = document.getElementById('autoSaveBtn');
      
      if (autoSaveEnabled) {
        btn.textContent = 'âœ… Auto-Save ON';
        btn.className = 'px-4 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm transition-colors';
        addLog('ğŸŸ¢ Salvamento automÃ¡tico ATIVADO');
      } else {
        btn.textContent = 'âŒ Auto-Save OFF';
        btn.className = 'px-4 py-2 bg-red-600 hover:bg-red-500 rounded-lg text-sm transition-colors';
        addLog('ğŸ”´ Salvamento automÃ¡tico DESATIVADO');
      }
    }

    // FunÃ§Ã£o para salvamento automÃ¡tico
    function autoSaveGetNanoLogs() {
      if (getNanoLogs.length === 0) return;

      const recentLogs = getNanoLogs.slice(-10); // Pegar Ãºltimos 10 logs relacionados ao GET atual
      
      const getNanoData = {
        exportDate: new Date().toISOString(),
        description: "Logs automÃ¡ticos do comando GET para Arduino Nano",
        autoSave: true,
        totalGetNanoLogs: recentLogs.length,
        getNanoLogs: recentLogs
      };

      const filename = `get_nano_auto_${getTimestampString()}.json`;
      downloadJSON(getNanoData, filename);
      
      addLog(`ğŸ’¾ Auto-save: ${recentLogs.length} logs salvos automaticamente`);
      addLog(`ğŸ“ Arquivo: ${filename}`);
    }

    // FunÃ§Ã£o para salvar apenas logs GET Nano (manual)
    function saveGetNanoLogs() {
      if (getNanoLogs.length === 0) {
        alert('Nenhum log GET Nano para salvar!');
        return;
      }

      const getNanoData = {
        exportDate: new Date().toISOString(),
        description: "Logs manuais dos comandos GET para Arduino Nanos",
        autoSave: false,
        totalGetNanoLogs: getNanoLogs.length,
        getNanoLogs: getNanoLogs
      };

      const filename = `get_nano_manual_${getTimestampString()}.json`;
      downloadJSON(getNanoData, filename);
      
      addLog(`ğŸ“¡ ${getNanoLogs.length} logs GET Nano salvos manualmente`);
      addLog(`ğŸ“ Arquivo: ${filename}`);
    }

    // FunÃ§Ã£o para mostrar instruÃ§Ãµes de como mover logs
    function showMoveInstructions() {
      addLog('ğŸ“ INSTRUÃ‡Ã•ES PARA MOVER LOGS:');
      addLog('1ï¸âƒ£ Abra terminal no diretÃ³rio do projeto');
      addLog('2ï¸âƒ£ Execute: ./move_logs.sh');
      addLog('3ï¸âƒ£ O script moverÃ¡ automaticamente de Downloads para logs/');
      addLog('ğŸ’¡ Ou mova manualmente da pasta Downloads para /home/elgin/front_teste_AM/logs/');
    }

    // FunÃ§Ã£o auxiliar para download de JSON
    function downloadJSON(data, filename) {
      const jsonString = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // FunÃ§Ã£o para gerar timestamp para nome do arquivo
    function getTimestampString() {
      const now = new Date();
      return now.getFullYear() + 
             String(now.getMonth() + 1).padStart(2, '0') + 
             String(now.getDate()).padStart(2, '0') + '_' +
             String(now.getHours()).padStart(2, '0') + 
             String(now.getMinutes()).padStart(2, '0') + 
             String(now.getSeconds()).padStart(2, '0');
    }

    // FunÃ§Ãµes de conexÃ£o
    async function connectPort3() {
      await connectPort('port3', 'Nano 1');
    }

    async function connectPort4() {
      await connectPort('port4', 'Nano 2');
    }

    async function connectPort(portKey, portName) {
      try {
        addLog(`ğŸ” Iniciando conexÃ£o ${portName}...`);

        const port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        
        const portData = {
          port,
          writer: port.writable.getWriter(),
          isReading: true
        };
        
        serialPorts.set(portKey, portData);
        portConnections.set(portKey, `${portName}_${Date.now()}`);
        
        // Resetar Arduino apÃ³s conexÃ£o
        addLog(`ğŸ”„ Resetando ${portName}...`);
        await resetArduinoNano(portKey);
        await delay(500);
        
        // Iniciar leitura
        startReading(portKey, portName);
        
        // Atualizar UI
        updatePortUI(portKey, portName, true);
        
        // Notificar API sobre mudanÃ§a de status
        sendConnectionStatus();
        
        addLog(`âœ… ${portName} conectado e resetado com sucesso`);
        
      } catch (error) {
        addLog(`âŒ Erro ao conectar ${portName}: ${error.message}`, 'error');
      }
    }

    async function disconnectPort3() {
      await disconnectPort('port3', 'Nano 1');
    }

    async function disconnectPort4() {
      await disconnectPort('port4', 'Nano 2');
    }

    async function disconnectPort(portKey, portName) {
      const portData = serialPorts.get(portKey);
      if (!portData) return;

      try {
        portData.isReading = false;
        
        if (portData.reader) {
          await portData.reader.cancel();
        }
        if (portData.writer) {
          portData.writer.releaseLock();
        }
        await portData.port.close();
        
        serialPorts.delete(portKey);
        portConnections.delete(portKey);
        
        updatePortUI(portKey, portName, false);
        
        // Notificar API sobre mudanÃ§a de status
        sendConnectionStatus();
        
        addLog(`ğŸ“¡ ${portName} desconectado`);
        
      } catch (error) {
        addLog(`âŒ Erro ao desconectar ${portName}: ${error.message}`, 'error');
      }
    }

    // Leitura de dados
    async function startReading(portKey, portName) {
      const portData = serialPorts.get(portKey);
      if (!portData || !portData.isReading) return;

      try {
        const reader = portData.port.readable.getReader();
        portData.reader = reader;

        while (portData.isReading) {
          const { value, done } = await reader.read();
          if (done) break;

          const text = new TextDecoder().decode(value);
          if (text.trim()) {
            addLog(`ğŸ“¡ â† ${portName}: ${text.trim()}`, 'receive');
          }
        }
      } catch (error) {
        if (!error.message.includes('cancelled')) {
          addLog(`âŒ Erro na leitura ${portName}: ${error.message}`, 'error');
        }
      } finally {
        if (portData.reader) {
          portData.reader.releaseLock();
        }
      }
    }

    // Envio de comandos
    async function sendGetCommand(portKey) {
      const portData = serialPorts.get(portKey);
      const portName = portKey === 'port3' ? 'Nano 1' : 'Nano 2';
      
      if (!portData) {
        alert(`${portName} nÃ£o conectado!`);
        return;
      }

      try {
        const command = 'GET\n';
        const encoder = new TextEncoder();
        await portData.writer.write(encoder.encode(command));
        
        addLog(`ğŸ“¡ â†’ ${portName}: GET`, 'send');
        
      } catch (error) {
        addLog(`âŒ Erro ao enviar GET para ${portName}: ${error.message}`, 'error');
      }
    }

    async function testBothPorts() {
      addLog('ğŸ”„ Testando ambos os Arduino Nanos...');
      
      if (serialPorts.has('port3')) {
        await sendGetCommand('port3');
        await delay(500);
      }
      
      if (serialPorts.has('port4')) {
        await sendGetCommand('port4');
        await delay(500);
      }
    }

    // Reset Arduino
    async function resetNano(portKey) {
      const portData = serialPorts.get(portKey);
      const portName = portKey === 'port3' ? 'Nano 1' : 'Nano 2';
      
      if (!portData) {
        alert(`${portName} nÃ£o conectado!`);
        return;
      }

      addLog(`ğŸ”„ Resetando ${portName} manualmente...`);
      await resetArduinoNano(portKey);
      addLog(`âœ… ${portName} resetado com sucesso`);
    }

    async function resetArduinoNano(portKey) {
      const portData = serialPorts.get(portKey);
      if (!portData) return;

      try {
        await portData.port.setSignals({ 
          dataTerminalReady: false, 
          requestToSend: false 
        });
        await delay(100);
        
        await portData.port.setSignals({ 
          dataTerminalReady: true, 
          requestToSend: true 
        });
        await delay(100);
        
      } catch (error) {
        const portName = portKey === 'port3' ? 'Nano 1' : 'Nano 2';
        addLog(`âŒ Erro no reset ${portName}: ${error.message}`, 'error');
      }
    }

    // UI helpers
    function updatePortUI(portKey, portName, connected) {
      const connectBtn = document.getElementById(`connect${portKey.charAt(0).toUpperCase() + portKey.slice(1)}`);
      const disconnectBtn = document.getElementById(`disconnect${portKey.charAt(0).toUpperCase() + portKey.slice(1)}`);
      const status = document.getElementById(`status${portKey.charAt(0).toUpperCase() + portKey.slice(1)}`);
      
      if (connected) {
        connectBtn.style.display = 'none';
        disconnectBtn.style.display = 'inline-block';
        status.textContent = 'Conectado âœ…';
        status.className = 'text-sm text-green-400';
      } else {
        connectBtn.style.display = 'inline-block';
        disconnectBtn.style.display = 'none';
        status.textContent = 'Desconectado';
        status.className = 'text-sm text-slate-500';
      }
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  </script>
</body>
</html>